/** 
 * 
 */
package utbm.ia54.ant2dgrid.skills

import utbm.ia54.ant2dgrid.capacities.PheromoneCapacity
import utbm.ia54.ant2dgrid.objects.Vector2i
import utbm.ia54.ant2dgrid.capacities.MotionCapacity
import java.util.UUID
import java.util.List
import utbm.ia54.ant2dgrid.objects.Cell
import utbm.ia54.ant2dgrid.capacities.EnvironmentManagerCapacity
import utbm.ia54.ant2dgrid.objects.AntBody
import utbm.ia54.ant2dgrid.Enum.CellState
import io.sarl.lang.core.Address
import java.util.Map
import java.util.HashMap
import java.util.ArrayList
import io.sarl.core.DefaultContextInteractions
import utbm.ia54.ant2dgrid.events.Influence
import java.util.concurrent.ThreadLocalRandom
import utbm.ia54.ant2dgrid.Enum.AntState
import utbm.ia54.ant2dgrid.capacities.AntCapacity
import utbm.ia54.ant2dgrid.events.PickFood
import utbm.ia54.ant2dgrid.events.PutFood

/** 
 * @author Michel
 * 
 */
skill MotionSkill implements MotionCapacity{
	uses DefaultContextInteractions
	
	var positionBefore : Vector2i
	
	private def hasFood(list : List<Cell>) : boolean {
		var bool = false
		for(cell : list){
			if(cell.state === CellState.FOOD){
				bool = true
			}
		}
		
		bool
	}

	private def hasHome(list : List<Cell>) : boolean {
		var bool = false
		for (cell : list) {
			if (cell.state === CellState.HOME) {
				bool = true
			}
		}

		bool
	}
	private def countHasHomePherommoneCell(list : List<Cell>): int{
		var i = 0
		for(cell : list){
			if(cell.pheromoneFood.intensity>0f){
				i++
			}
		}
		i
	}
	
	def move(newpos : Vector2i, body : AntBody){
		emit(new Influence(newpos, body))
	}
	
	def randomMove(listPerception : List<Cell>, body : AntBody){
		val randomNum = ThreadLocalRandom.current().nextInt(0, listPerception.length)
		var newPos : Vector2i
		var cell = listPerception.get(randomNum)
		var i = countHasHomePherommoneCell(listPerception)
		
		switch (cell.state) {
			case CellState.NORMAL:
				if((hasFood(listPerception)===true && body.state === AntState.SEARCH_FOOD) ||
					(hasHome(listPerception) ===true && body.state === AntState.RETURN_HOME)){
					randomMove(listPerception, body)
				} else {
					if (i === listPerception.size) {
						newPos = cell.position
						emit(new Influence(newPos, body))
						setPositionBefore(newPos)
					} else if (i < listPerception.size) {
						if (isEquals(cell.position) === false) {
							newPos = cell.position
							emit(new Influence(newPos, body))
							setPositionBefore(newPos)
						} else {
							randomMove(listPerception, body)
						}
					}
					
				}
				
			case CellState.WALL:
				randomMove(listPerception, body)
			case CellState.HOME:
				if (body.state === AntState.RETURN_HOME || isEquals(cell.position) === false) {
					newPos = cell.position
					emit(new Influence(newPos, body))
					setPositionBefore(newPos)
				} else {
					randomMove(listPerception, body)
				}
			case CellState.FOOD:
				if (body.state === AntState.SEARCH_FOOD) {
					newPos = cell.position
					emit(new Influence(newPos, body))
					setPositionBefore(newPos)
				} else if (body.state === AntState.RETURN_HOME) {
					randomMove(listPerception, body)
				}
		}
	}
	
	def stay(body: AntBody){
		emit(new Influence(body.position, body))
	}
	
	def setPositionBefore(pos : Vector2i) {
		positionBefore = pos
	}
	
	private def isEquals(pos : Vector2i) : boolean{
		this.positionBefore.equals(pos)
	}
	
}

skill PheromoneSkill implements PheromoneCapacity{
	
	def followPheromone(listPerception : List<Cell>, state : AntState) : Cell {

		var tempCell : Cell
		var foodCell : Cell
		var homeCell : Cell
		var bool = false
		var food = false
		var home = false
		var pheromoneFood = 0f
		var pheromoneHome = 0f
		
		switch(state){
			case AntState.SEARCH_FOOD:
				for (var i = 0; i < listPerception.length; i++) {
					if (food === false) {
						if (listPerception.get(i).state === CellState.FOOD) {
							foodCell = listPerception.get(i)
							tempCell = foodCell
							food = true
						} else {
							if (pheromoneFood < listPerception.get(i).pheromoneFoodIntensity) {
								pheromoneFood = listPerception.get(i).pheromoneFoodIntensity
								tempCell = listPerception.get(i)
								bool = true
							}
						}
					}
				}
				
			case AntState.RETURN_HOME:
				for (var i = 0; i < listPerception.length; i++) {
					if (home === false) {
						if (listPerception.get(i).state === CellState.HOME) {
							homeCell = listPerception.get(i)
							tempCell = homeCell
							home = true
						} else {
							if (pheromoneHome < listPerception.get(i).pheromoneHomeIntensity) {
								pheromoneHome = listPerception.get(i).pheromoneHomeIntensity
								tempCell = listPerception.get(i)
								bool = true
							}
						}
					}
				}
		}
		
		if(bool === false){
			tempCell = new Cell(-1, -1)
		}
		tempCell
	}	
}

skill AntManagerSkill implements AntCapacity{
	
	uses DefaultContextInteractions
	
	def pickUpFood(body : AntBody) {
		emit(new PickFood(body))
	}
	
	def putDownFood(body : AntBody) {
		emit(new PutFood(body))
	}
	
}

skill EnvironmentManagerSkill implements EnvironmentManagerCapacity{
	
	val width : int
	val height : int
	var grid : List<Cell>
	val antQuantity : int
	var homeCellPosition : int
	var foodCellPosition : int
	var antAddresses : Map<UUID, Address>
	
	new(width : int, height : int, grid : List<Cell>, quantity : int) {
		this.width = width
		this.height = height
		this.grid = grid
		this.antQuantity = quantity
		this.antAddresses = new HashMap<UUID, Address>
		defineCell	
	}
	
	private def defineCell {
		for (var i = 0; i < width; i++) {
			for (var j = 0; j < height; j++) {
				if (grid.get(i * height + j).state === CellState.HOME) {
					homeCellPosition = (i * height + j)
				} else if (grid.get(i * height + j).state === CellState.FOOD) {
					foodCellPosition = (i * height + j)
				}
			}
		}
	}
	
	def getWidth : int {
		this.width
	}
	
	def getHeight : int {
		this.height
	}
	
	def getGrid : List<Cell> {
		this.grid
	}
	
	def getAntQuantity : int{
		this.antQuantity
	}
	
	def createAnt (position : Vector2i, id : UUID, body : AntBody){
		this.grid.get(position.x * height + position.y).addAnt(id, body)
		this.grid.get(position.x * height + position.y).evaporationPheromoneFood
		this.grid.get(position.x * height + position.y).evaporationPheromoneHome
	}
	
	def getHomeCell : Cell {
		getCell(homeCellPosition)
	}
	
	def getFoodCell : Cell {
		getCell(foodCellPosition)
	}
	
	def getCell(i : int) : Cell {
		this.grid.get(i)
	}
	
	def setAddress(id : UUID, address : Address) {
		this.antAddresses.put(id, address)
	}
	
	def getAddress(id : UUID): Address {
		this.antAddresses.get(id)
	}
	
	def getPerception(id : UUID) : List<Cell> {
		var list = new ArrayList<Cell>
		var vector = getAntPosition(id)
		if((vector.x + 1) < width){
			list.add(grid.get((vector.x + 1) * height + vector.y))
		}
		if((vector.y + 1) < height){
			list.add(grid.get(vector.x * height + (vector.y + 1)))
		}
		if((vector.x - 1 )>-1){
			list.add(grid.get((vector.x - 1) * height + vector.y))
		}
		if((vector.y - 1) > -1){
			list.add(grid.get(vector.x * height + (vector.y - 1)))
		}
		
		/*
		for (var i = -1; i < 2; i++) {
			for (var j = -1; j < 2; j++) {
				var temp_vector = new Vector2i(i, j)
				temp_vector.plus(vector)
				if (temp_vector.x*height+temp_vector.y<height*width) {
					if(temp_vector.x < 0 || temp_vector.y<0 || temp_vector.x>height || temp_vector.y>width){
						if ((i===0 && (j===-1 || j===1)) || (j ===0 && (i===-1 || i===1))) {
							list.add(grid.get(temp_vector.x * height + temp_vector.y))
						}
					}
				}
				
			}
		}*/
		list
	}
	
	def getAntAddresses : Map<UUID, Address> {
		this.antAddresses
	}
	
	private def getAntPosition(id : UUID) : Vector2i {
		var v : Vector2i
		for (var i = 0; i < width; i++) {
			for (var j = 0; j < height; j++) {
				if(grid.get(i*height+j).antList.containsKey(id)){
					v = new Vector2i(i,j)
				}
			}
		}
		v
	}
	
	def removeAntCell(position : Vector2i, id : UUID, body: AntBody) {
		getCell(position.x*height+position.y).removeAnt(id, body)
	}
	
}